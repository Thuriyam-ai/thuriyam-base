_templates_suffix: .jinja
_envops:
    block_start_string: "{%"
    block_end_string: "%}"
    variable_start_string: "{{"
    variable_end_string: "}}"

project_name:
    type: str
    help: What is the name of your microservice? (e.g., user-service, payment-service)
    placeholder: my-service

service_description:
    type: str
    help: Brief description of what this service does
    default: A FastAPI-based microservice

python_module_name:
    type: str
    help: Python module name (snake_case version of project name)
    default: "{{ project_name.replace('-', '_').replace(' ', '_').lower() }}"

org_name:
    type: str
    help: Organization name
    default: Thuriyam

version:
    type: str
    help: Initial version
    default: "0.1.0"

author_name:
    type: str
    help: Author name
    default: "{{ org_name }}"

author_email:
    type: str
    help: Author email
    default: "contact@{{ org_name.lower() }}.ai"

modules:
    type: str
    help: Comma-separated list of module names (e.g., users,products,orders)
    default: users
    validator: >-
        {% set module_list = modules.split(',') %}
        {% for module in module_list %}
        {% set clean_module = module.strip() %}
        {% if not clean_module.isidentifier() %}
        Each module name must be a valid Python identifier: "{{ clean_module }}" is invalid
        {% endif %}
        {% endfor %}

use_postgres:
    type: bool
    help: Use PostgreSQL instead of SQLite?
    default: true

database_name:
    type: str
    help: Database name
    default: "{{ python_module_name }}_db"
    when: "{{ use_postgres }}"

database_user:
    type: str
    help: Database user
    default: "{{ org_name | lower }}_user"
    when: "{{ use_postgres }}"

database_password:
    type: str
    help: Database password
    default: "{{ org_name | lower }}_password"
    when: "{{ use_postgres }}"

include_docker:
    type: bool
    help: Include Docker configuration files?
    default: true

include_alembic:
    type: bool
    help: Include Alembic for database migrations?
    default: true

api_prefix:
    type: str
    help: API prefix path
    default: "/api/v1"

jwt_secret_key:
    type: str
    help: JWT secret key for authentication
    default: "your-secret-key-change-in-production"

_tasks:
    # Rename base module template to first module name and replace placeholders
    - command: |
        {% set module_list = modules.split(',') %}
        {% set first_module = module_list[0].strip() %}
        if [ -d "app/_module_template" ]; then
            mv "app/_module_template" "app/{{ first_module }}"
            echo "Renamed base template to {{ first_module }}"
            
            # Calculate names for the first module
            MODULE_NAME="{{ first_module }}"
            if [[ "{{ first_module }}" == *s ]]; then
                base_name="{{ first_module[:-1] }}"
                CLASS_NAME=$(echo "$base_name" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
                SINGULAR_NAME="$base_name"
                SINGULAR_VAR_NAME="$base_name"
            else
                CLASS_NAME=$(echo "{{ first_module }}" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
                SINGULAR_NAME="{{ first_module }}"
                SINGULAR_VAR_NAME="{{ first_module }}"
            fi
            
            # Replace placeholders in Python files for the first module
            find "app/{{ first_module }}" -name "*.py" -type f -exec sed -i.bak \
                -e "s/__MODULE_NAME__/$MODULE_NAME/g" \
                -e "s/__CLASS_NAME__/$CLASS_NAME/g" \
                -e "s/__SINGULAR_NAME__/$SINGULAR_NAME/g" \
                -e "s/__SINGULAR_VAR_NAME__/$SINGULAR_VAR_NAME/g" \
                {} \;
                
            # Clean up backup files
            find "app/{{ first_module }}" -name "*.bak" -delete
        fi
    # Create additional module directories for multi-module setup  
    - command: |
        {% set module_list = modules.split(',') %}
        {% if module_list|length > 1 %}
        {% set first_module = module_list[0].strip() %}
        {% for module in module_list[1:] %}
        {% set clean_module = module.strip() %}
        if [ -d "app/{{ first_module }}" ] && [ ! -d "app/{{ clean_module }}" ]; then
            echo "Creating module: {{ clean_module }}"
            cp -r "app/{{ first_module }}" "app/{{ clean_module }}"
            
            # Calculate names for replacement
            MODULE_NAME="{{ clean_module }}"
            if [[ "{{ clean_module }}" == *s ]]; then
                base_name="{{ clean_module[:-1] }}"
                CLASS_NAME=$(echo "$base_name" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
                SINGULAR_NAME="$base_name"
                SINGULAR_VAR_NAME="$base_name"
            else
                CLASS_NAME=$(echo "{{ clean_module }}" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
                SINGULAR_NAME="{{ clean_module }}"
                SINGULAR_VAR_NAME="{{ clean_module }}"
            fi
            
            # Calculate names for the first module to replace
            FIRST_MODULE_NAME="{{ first_module }}"
            if [[ "{{ first_module }}" == *s ]]; then
                first_base_name="{{ first_module[:-1] }}"
                FIRST_CLASS_NAME=$(echo "$first_base_name" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
                FIRST_SINGULAR_NAME="$first_base_name"
                FIRST_SINGULAR_VAR_NAME="$first_base_name"
            else
                FIRST_CLASS_NAME=$(echo "{{ first_module }}" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
                FIRST_SINGULAR_NAME="{{ first_module }}"
                FIRST_SINGULAR_VAR_NAME="{{ first_module }}"
            fi
            
            # Replace first module values with current module values (avoid replacing current_user)
            find "app/{{ clean_module }}" -name "*.py" -type f -exec sed -i.bak \
                -e "s/from $FIRST_MODULE_NAME\./from $MODULE_NAME./g" \
                -e "s/\b$FIRST_MODULE_NAME\b/$MODULE_NAME/g" \
                -e "s/\b$FIRST_CLASS_NAME\([A-Z]\)/$CLASS_NAME\1/g" \
                -e "s/\b$FIRST_CLASS_NAME\b/$CLASS_NAME/g" \
                -e "s/create_$FIRST_SINGULAR_VAR_NAME/create_$SINGULAR_VAR_NAME/g" \
                -e "s/get_$FIRST_SINGULAR_VAR_NAME/get_$SINGULAR_VAR_NAME/g" \
                -e "s/update_$FIRST_SINGULAR_VAR_NAME/update_$SINGULAR_VAR_NAME/g" \
                -e "s/patch_$FIRST_SINGULAR_VAR_NAME/patch_$SINGULAR_VAR_NAME/g" \
                -e "s/delete_$FIRST_SINGULAR_VAR_NAME/delete_$SINGULAR_VAR_NAME/g" \
                -e "s/get_$FIRST_MODULE_NAME/get_$MODULE_NAME/g" \
                -e "s/$FIRST_SINGULAR_VAR_NAME\_data/$SINGULAR_VAR_NAME\_data/g" \
                -e "s/$FIRST_SINGULAR_VAR_NAME\_service/$SINGULAR_VAR_NAME\_service/g" \
                -e "s/$FIRST_SINGULAR_VAR_NAME\_id/$SINGULAR_VAR_NAME\_id/g" \
                {} \;
                
            # Clean up backup files
            find "app/{{ clean_module }}" -name "*.bak" -delete
        fi
        {% endfor %}
        {% endif %}
      when: "{{ modules.split(',') | length > 1 }}"
    # Standard post-generation tasks
    - command: "chmod +x scripts/*.sh"
      when: "{{ include_docker }}"
    - command: "chmod +x scripts/*.py"
    - command: "echo 'Microservice {{ project_name }} created successfully!'"
    - command: "echo 'Generated modules: {{ modules }}'"
    - command: "echo 'Next steps:'"
    - command: "echo '1. cd {{ _copier_conf.dst_path }}'"
    - command: "echo '2. Review and update .env files'"
    - command: "echo '3. Run: python -m venv venv && source venv/bin/activate'"
    - command: "echo '4. Run: pip install -e .'"
    - command: "echo '5. Run database migrations if using PostgreSQL'"
    - command: "echo '6. Start development: python main.py runserver'"
    - command: "echo 'Or use Docker: cd build && docker-compose up -d'" 
      when: "{{ include_docker }}" 