from datetime import timedelta
from typing import Optional
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.settings import get_config
from app.core.database import get_db
from app.core.base.model import ModelBuilder, Operation
from app.core.security.auth import verify_password, get_password_hash
from app.core.security.jwt import create_access_token
from app.{{ entity }}.model import {{ entity.title() }}
from app.{{ entity }}.schema import {{ entity.title() }}Create, {{ entity.title() }}Update, {{ entity.title() }}Response
from app.{{ entity }}.repository import {{ entity.title() }}Repository
from app.{{ entity }} import ensure_validators_registered

settings = get_config()

class {{ entity.title() }}Service:
    def __init__(self, db: Session = Depends(get_db)):
        ensure_validators_registered()
        self.repository = {{ entity.title() }}Repository(db)

    def create{{ entity.title() }}(self, input: {{ entity.title() }}Create) -> {{ entity.title() }}Response:
        # TODO: Validate user input

        # Building a model using the ModelBuilder instead of the existing build function.
        {{ entity }} = ModelBuilder.for_model({{ entity.title() }}).with_operation(
            Operation.CREATE
        ).with_attributes(
            input.model_dump(exclude_unset=True)
        ).build()

        {{ entity }}_model = self.repository.save({{ entity }})
        return {{ entity.title() }}Response.model_validate({{ entity }}_model)

    def update(self, id: str, input: {{ entity.title() }}Update) -> Optional[{{ entity.title() }}Response]:
        # TODO: Add validation for the input

        # Update the {{ entity }} with the input data
        {{ entity }}_model = self.repository.update(
            id, 
            input.model_dump(exclude_unset=True)
        )
        if not {{ entity }}_model:
            raise HTTPException(status_code=404, detail="{{ entity.title() }} not found")
            
        return {{ entity.title() }}Response.model_validate({{ entity }}_model)

    def delete(self, id: str) -> bool:
        # TODO: Add validation for the input

        # Delete the {{ entity }} with the given id
        return self.repository.delete(id)

    def list(self, skip: int = 0, limit: int = 100) -> list[{{ entity.title() }}Response]:
        list = self.repository.find_all(skip=skip, limit=limit)
        return [{{ entity.title() }}Response.model_validate(item) for item in list]

    def get(self, id: str) -> Optional[{{ entity.title() }}Response]:
        {{ entity }} = self.repository.find(id)
        if not {{ entity }}:
            return None
        return {{ entity.title() }}Response.model_validate({{ entity }})